#nop .-----------------.
#nop |   status log    |
#nop .-----------------.
#alias statushelp { #nop << help alias;
    #echo {--- TinFrame status pane handling --- };
    #echo {showstatus              : update status pane (usually automatic) };
    #echo {flagon/flagoff <flag>   : set or clear a flag};
    #echo {clearflags              : clear all flags};
    #echo {flagif <flag> <trigger> : flagon  on ^trigger mud line};
    #echo {unflagif <flag> <trig>  : flagoff on ^trig    mud line};
    #echo {sproperty <key> <value> : set property key->value};
    #echo {spropclear <key>        : clear a property, or all if no key given};
    #echo {buffon/buffoff <buff>   : set buff as active/inactive};
    #echo {buffif <buff> <trigger> : buffon  on ^trigger mud line};
    #echo {unbuffif <buff> <trig>  : buffoff on ^trig    mud line};
    #echo {tossbuff <buff>         : remove buff from all lists};
    #echo {autobuff/custombuff/stopbuff - partially implemented for bot-allowing muds};
};
#nop >>;

#nop associative tables: statusflags, dispbuffs, activebuffs, autobuffs, queuedbuffs, custombuffs;
#nop << make sure the hashes exist - but make sure they don't get killed when reloading class;
#nop these lists must live in 'temp', so that they don't get erased when reloading the libs;
#class temp open;
#if {&statusflags} {#nop;} {#var statusflags {}};
#if {&dispbuffs}   {#nop;} {#var dispbuffs   {}};
#if {&activebuffs} {#nop;} {#var activebuffs {}};
#if {&autobuffs}   {#nop;} {#var autobuffs   {}};
#if {&queuedbuffs} {#nop;} {#var queuedbuffs {}};
#if {&custombuffs} {#nop;} {#var custombuffs {}};
#if {&statusprops} {#nop;} {#var statusprops {}};
#class statuslib open;
#nop >>;

#nop displaying in status pane
#nop << showstatus
#nop colors for on/off buffs (can be overrridden);
#var oncol  {$cgreen};
#var offcol {$cgray}; 
#var keycol {$clblue};
#var valcol {$cyellow};
#var flcol  {$ccyan};
#var recol  {$cwhite};

#alias showstatus {
  #nop first clear the status pane;
  #var thecount 0;
  #while { $thecount < 7 } {
    #math thecount { $thecount + 1};
    statuslog { };
  };
  #nop then display the status flags line;
  #var flagline {$flcol};
  #foreach {$statusflags[]} {flag} {
    #format flagline {%s%u$recol } {$flagline} {$flag};
  };
  statuslog {$flagline}; #nop make sure this is not empty! (vs bug of capturing next from main pane);
  #nop then display the properties line;
  #var propline {};
  #foreach {$statusprops[]} {prop} {
    #format propline {%s%s$recol  } {$propline} {$keycol$prop: $valcol$statusprops[$prop]};
  };
  statuslog {$propline};
  #nop finally display the buffs;
  #unvar temp;
  #foreach {$dispbuffs[]} {buff} {
    #if {&activebuffs[$buff]} {
      #var nextbuff {$oncol$buff$recol };
    }{
      #var nextbuff {$offcol$buff$recol };
    };
    #if {&tempc} {
      statuslog {$templ$tempc$nextbuff};
      #unvar tempc;
      #unvar templ;
    }; 
    #elseif {&templ} {
      #format tempc {%-20s} {$nextbuff};
    };
    #else {
      #format templ {%-20s} {$nextbuff};
    };
  };
  #if &templ {
    #if &tempc {
      statuslog {$templ$tempc$recol };
    } {
      statuslog {$templ$recol };
    };
    #unvar tempc;
    #unvar templ;
  };
#nop   statuslog {$recol };
  #showme { };
};
#nop >>;

#nop flag status handling;
#nop << flagon{flag}, flagoff{flag}, clearflags{} (means clear all);
#nop define the "methods";
#alias flagon {
  #if {"%1" == ""} {
    #echo {> flagon needs a flag name <};
  }{
    #var {statusflags[%1]} {on};
    showstatus;
  }
}
#alias flagoff {
  #if {"%1" == ""} {
    #echo {> flagoff needs a flag name <};
  }{
    #unvar statusflags[%1];
    showstatus;
  }
}
#alias clearflags {
  #var statusflags {};
    showstatus;
}
#nop >>
#nop << flagif{flag}{trigger}, unflagif{flag}{trigger};
#alias flagif {
  #high {^%2} {<bad>};
  #act {^%2} {
    flagon {%1};
  };
};
#alias unflagif {
  #high {^%2} {<bad>};
  #act {^%2} {
    flagoff {%1};
  };
};
#nop >>

#nop property status handling;
#nop << sproperty{key}{val}, spropclear{key};
#nop define the "methods";
#alias sproperty {
  #if {"%1" == ""} {
    #echo {> sprop needs a property name <};
  }{
    #var {statusprops[%1]} {%2};
    showstatus;
  };
}
#alias spropclear {
  #if {"%1" == ""} {
    #var statusprops {};
    showstatus;
  }{
    #unvar {statusprops[%1]};
    showstatus;
  };
}
#nop >>

#nop buff status handling
#nop << buffon/buffoff {buffname} - make buff active/inactive;
#alias buffon {
  #if {"%1" == ""} {
    #echo {> buffon needs a flag name <};
  }{
    #nop add buff to display list, in case it wasn't there yet;
    #var dispbuffs[%1] {1};
    #nop add buff to active buffs list;
    #var activebuffs[%1] {on};
    #unvar queuedbuffs[%1];
    showstatus;
  }
}
#alias buffoff {
  #if {"%1" == ""} {
    #echo {> buffoff needs a flag name <};
  }{
    #nop add buff to display list, in case it wasn't there yet;
    #var dispbuffs[%1] {1};
    #nop remove buff from active buffs list;
    #unvar activebuffs[%1];
    #if {&autobuffs[%1]} {
      rebuff {%1};
    };
    showstatus;
  }
}
#nop >>;
#nop << buffif, buffoff and their 'ambiguous' counterparts for creating on/off buff detectors;
#alias buffif {
  #high {^%2} {<bda>};
  #nop create action to detect buff went on;
  #act {^%2} {
    buffon {%1};
  };
};
#alias unbuffif {
  #high {^%2} {<bda>};
  #nop create action to detect buff went off;
  #act {^%2} {
    buffoff {%1};
  };
};
#nop >>;
#nop << tossbuff{name} -- removes buff from all tables
#alias tossbuff {
  #unvar autobuffs[%1];
  #unvar dispbuffs[%1];
  #unvar activebuffs[%1];
  #unvar custombuffs[%1];
  #unvar queuedbuffs[%1];
  showstatus;
}
#nop >>

#nop << autobuff{name}{minmana}, custombuff{name}{action}
#alias autobuff {
  #var autobuffs[%1] {%2};
}
#alias custombuff {
  #var custombuffs[%1] {%2};
}
#nop >>
#nop << stopbuff{name} -- removes buff from auto-rebuff table 
#alias stopbuff {
  #unvar autobuffs[%1];
  showstatus;
}
#nop >>
#nop ------------------------
#nop CopyLeft by dalker
#nop create date: 2016-04-14
#nop modif  date: 2016-05-29
