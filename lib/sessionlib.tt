#nop ---------------------------------------------------------------------- 
#nop session handling: connection, activation, disconnection and timing out 
#nop ---------------------------------------------------------------------- 
#nop << help alias for TinFrame session handling;
#alias sessionhelp {
    #echo {--- TinFrame session help --- };
    #echo {E 'onconnect' is a placeholder for actions to perform on connection};
    #echo {E 'onactive' is a placeholder for actions to perform on session change};
    #echo {E 'prequit' is a placeholder for actions to perform right before quitting};
    #echo {  'quit' really calls 'prequit' before sending mud the 'quit' command};
    #echo {  'onquit' calls 'memchar' and closes map if char defined};
    #echo {  'memchar' memorizes map location and status buffs/flags/properties on quit};
    #echo {E 'postquit' is a placeholder for any 'memalso' to perform after memchar};
    #echo {  'memalso' adds a line to char's memfile, if char defined};
    #echo {  'ontimeout' and 'posttimeout' call their quit counterparts by default};
    #echo {  'loginas' sets a char, loads its class, calls loginsequence and recallchar, };
    #echo {            or lists available chars if none is given};
    #echo {  'loginsequence' sends \$name and \$pass by default - may be overridden};
    #echo {  'postlogin' does nothing by default - may be overridden};
    #echo {  'recallchar' is the counterpart to 'memchar'/'memalso'};
    #echo {E = empty by default , others may be overridden if needed on a per-mud basis};
}
#nop >>;
#nop - alias 'loginas' to login using a character defined on a chars/ .tt file and recall information about it
#nop - caller-overrideable 'loginsequence' and 'postlogin'
#nop - aliases 'memchar', 'memalso', 'recallchar' for use in 'onconnect' and 'onquit'
#nop - caller-overrideable 'onconnect', 'prequit', 'onquit', 'ontimeout' are called when connecting / disconnecting
#nop determine if this is multinframe
#nop << auto-set $activesession, auto-save map, log connection/disconnection and call 'onconnect', 'onquit', ...;
#alias fetchdate {#script thedate {date +"%Y.%m.%d - %H:%M"}}
#event {SESSION CONNECTED}{
 #var activesession %0;
 fetchdate;
 loglog {* * * connected to $mudname on $thedate[1] * * *};
 #unvar thedate;
 onconnect; #nop may contain loginas and/or recallchar;
}
#event {SESSION ACTIVATED} {
  #var activesession %0;
  onactive;
} 

#event {SESSION DISCONNECTED}{
 #system {cd panes; ln -sf start_log.txt log.txt};
 fetchdate;
 loglog {* * * disconnected from $mudname on $thedate[1] * * *};
 #unvar thedate;
 onquit; #nop typically contains memmap - so must be done *before* closing map;
 #if &mapfile {
   closemap;
   #echo {map cleanly closed on disconnection.};
 };
 postquit;
 #nop note that *after* this, session data is definitely lost;
}

#event {SESSION TIMED OUT}{
 #system {cd panes; ln -sf start_log.txt log.txt};
 fetchdate;
 loglog {* * * timed out from $mudname on $thedate[1] * * *};
 #unvar thedate;
 ontimeout; #nop normally calls 'onquit', but can be overridden;
 #if &mapfile {
   closemap;
   #echo {map cleanly closed on timeout.};
 };
 posttimeout; #nop normally calls 'postquit', but can be overridden;
 #nop note that *after* this, session data is definitely lost;
}
#nop >>
#nop << auxiliary functions for 'onquit', 'onconnect' and friends : memchar, memalso, recallchar;
#alias memchar {#nop <<;
  #format {memfile} {%s%s%s} {chars/} {%1} {.mf};
  #system {rm $memfile 2> /dev/null};

  #nop save map information, if any;
  #if { &mapfile } {
    #map get roomvnum lastvnum;

    #line log {$memfile} {#nop map last location recall for %1};
    #line log {$memfile} {loadmap $currentmap $lastvnum};

    #echo {memchar for $name: saved map $currentmap vnum $lastvnum};
  };
  #else {#line log {$memfile} {#echo no map information saved for %1}};

  #nop save status information, if any;
  #foreach $dispbuffs[]   buff {#line log {$memfile} {#var dispbuffs[$buff]   {saved}}};
  #foreach $activebuffs[] buff {#line log {$memfile} {#var activebuffs[$buff] {saved}}};
  #foreach $autobuffs[]   buff {#line log {$memfile} {#var autobuffs[$buff]   {$autobuffs[$buff]}}};
  #foreach $statusflags[] flag {#line log {$memfile} {#var statusflags[$flag] {$statusflags[$flag]}}};
  #foreach $statusprops[] key  {#line log {$memfile} {#var statusprops[$key]  {$statusprops[$key]}}};
};#nop >>

#alias memalso {
  #if &char {
    #line log {$memfile} {%1};
  };
};

#alias recallchar {
  #format {memfile} {%s%s%s} {chars/} {%1} {.mf};
  #read {$memfile};
  #echo {recalled memfile for %1};
};
#nop >>
#nop << default versions of 'onconnect', 'onactive', 'prequit', 'quit' override, 'onquit', 'postquit', 'ontimeout', 'posttimeout';
#alias onconnect {#nop override this alias on mud tt file if necessary;}
#alias onactive {setuppanes; #nop override this alias on mud tt file if necessary;}

#alias prequit {
  #nop stuff to be done before 'quit' command is sent to mud;
  #nop override this alias on mud tt file if necessary;
}

#var prequitdelay {0.2}
#alias quit {
  #nop delay actual quit in case 'prequit' script needs to do some stuff before;
  #delay $prequitdelay {#send quit};
  prequit;
};

#alias onquit {
  #nop stuff to be done before map is closed;
  #nop override this alias on mud tt file if necessary;
  #nop by default, character's map location is saved;
  #if &char {
    memchar $char;
    closemap;
  }
  #nop typically any other info would be saved later on postquit;
}

#alias postquit {
  #nop extra bits of quit handling after map is closed;
  #nop override this alias on mud tt file if necessary;
  #nop e.g.: "memalso {#nop extra stuff};"
}

#alias ontimeout {
  #nop stuff to be done before map is closed;
  #nop override this alias on mud tt file if necessary;
  onquit;
}

#alias posttimeout {
  #nop extra bits of quit handling after map is closed;
  #nop override this alias on mud tt file if necessary;
  postquit;
}
#nop >>
#nop << 'loginas' alias and accesories: loginsequence, postlogin, showallchars, setuppanes
#alias loginsequence { #nop << override this alias on mud tt file if necessary;
  $name;
  $pass;
}; #nop >>
#alias postlogin { #nop << override this alias on mud tt file if necessary;
}; #nop >>
#alias showallchars { #nop <<;
  #script {allcharnames} {ls chars/*.tt | sed -e s#chars/## -e s#.tt## | xargs};
  #echo {<040>possible chars: $allcharnames[1]<099>};
  #unvar allcharnames;
}; #nop >>
#alias setuppanes { #nop << called by setupchar, and by multi changes;
  #if {&char} {#system {
    cd panes;
    touch ${char}_log.txt;  ln -sf ${char}_log.txt  log.txt;
    touch ${char}_chat.txt; ln -sf ${char}_chat.txt chat.txt;
#nop     touch ${char}_map.txt;  ln -sf ${char}_map.txt  map.txt;
    echo --== $char status ==-- > ${char}_status.txt; ln -sf ${char}_status.txt status.txt;
  }} {
    setstartlogs;
  };
  #if {$multi > 0} {
    #system {cd panes; touch ${char}_other.txt; ln -sf ${char}_other.txt other.txt};
  };
  #if {$multi > 1} {
    #system {cd panes; touch ${char}_third.txt; ln -sf ${char}_third.txt third.txt};
  };
}; #nop >>
#alias setupchar { #nop << optional: give char as argument (otherwise $char is used);
  #if {"%1" != ""} {#var char %1};
  #if {&char} {
    #var loglogfile    {panes/${char}_log.txt};
    #var chatlogfile   {panes/${char}_chat.txt};
    #var statuslogfile {panes/${char}_status.txt};
    setuppanes;
    subclassinclude {chars} {$char};
  }
}; #nop >>
#alias loginas {; #nop << with $char as argument;
  #nop show available chars if no char or non-existant char asked for;
  #script {charnames} {ls chars/*.tt | sed -e s#chars/## -e s#.tt##};
  #var index 0;
  #list charnames find {%1} index;
  #if { "%1" == "" || $index == 0 } { 
    #echo {<020>loginas needs a character name for which a config file exists};
    showallchars;
  };
  #unvar index;

  #nop otherwise define and login $char and recall its "memory" (map location, ...);
  #else {
    #var char {%1};
    setupchar $char; #nop notably sets up panes and recalls char's class file;
    #if {&name} {#nop;} {#var name {$char}}; #nop in case char's file didn't define $name;
    recallchar $char; #nop character's memorized map and other variables are recalled;
    loginsequence;
    fetchdate; loglog {<024>Logged in as $name on $thedate[1]<099>}; #unvar thedate;
    postlogin;
  };
};#nop >>
#nop >>
#var logindelay .5;
#nop << mutlichar handling
#script temp {echo $MULTI}; #var multi $temp[1]; #unvar temp;
#if {$multi} {
  #function sessionisgts {
    #if {&activesession && "$activesession" != "gts"} {#return 0} {#return 1};
  };
  #nop initialize persistent gts variables if no session exists at all;
  #if {&activesession} {#nop;} {
    #class temp open;
    #list  sessions clear;
    #var   sessionindex    0;
    #var   maxsessionindex 0;
    #class sessionlib open;
  };
  #alias newsession {
    #list sessions add %1;
    #list sessions size maxsessionindex;
    #var  sessionindex  maxsessionindex;
  };
  #alias gotoprevsession {
    #if {$sessionindex == 1} {
      #var sessionindex $maxsessionindex;
    } {
      #math sessionindex {$sessionindex - 1};
    };
    #format thecommand {#%s} {$sessions[$sessionindex]};
    $thecommand;
    #unvar thecommand;
  };
  #alias gotonextsession {
    #if {$sessionindex == $maxsessionindex} {
      #var sessionindex 1;
    } {
      #math sessionindex {$sessionindex + 1};
    };
    #format thecommand {#%s} {$sessions[$sessionindex]};
    $thecommand;
    #unvar thecommand;
  };
  #macro {\eOP} {#gts gotoprevsession}; #nop <F1>;
  #macro {\eOQ} {#gts gotonextsession}; #nop <F2>;
  #alias startsession { #nop << startsession <session> [char];
    #gts newsession %1; 
    #ses %1 $mudhost $mudport;
    #if {"%2" != ""} {
      #var char %2;
      loginas %2;
    };
  }; #nop >>;
  #alias startone {startsession {one} {%1}};
  #alias starttwo {startsession {two} {%1}};
  #if {$multi > 1} {#alias starttre {startmulti {tre} {%1}}};
  #alias onactive { #nop << standard override for multis;
    #if {"$activesession" == "gts"} {
      #echo {<bce>restart multisession with: <cbf>startone [char], starttwo [char]<099>};
      setuppanes;
      showallchars;
    };
    #nop Otherwise we're in a true session;
    #else {
      setuppanes;
      showstatus;
      #if {&currentmap} {redrawmap};
      #if {"$activesession" == "one"} {
        #one #log off;
        #two #log append panes/other.txt;
        #two #showme {-- background character is $otherchar --};
        #two #var otherchar $name;
        #one #unvar inthebackground;
        #two #var inthebackground yes;
      };
      #if {"$activesession" == "two"} {
        #two #log off;
        #one #log append panes/other.txt;
        #one #showme {-- background character is $otherchar --};
        #one #var otherchar $name;
        #two #unvar inthebackground;
        #one #var inthebackground yes;
      };
      #echo {-- active session is #$activesession with character $name --};
    };
  };#nop >>;
  #nop << show message if gts (never sessioned, or quit session and detected gts);
  #if {@sessionisgts} {
    #delay .2 {
      #echo {<bce>start multisession with: <cbf>startone [char], starttwo [char]<099>};
      showallchars;
    };
  };
  #nop >>;
}; #nop >>
#nop------------------------
#nop CopyLeft by dalker
#nop create date: 2016-05-28
#nop modif  date: 2016-07-03
